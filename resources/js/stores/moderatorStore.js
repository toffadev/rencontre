/**
 * Store Pinia pour la gestion de l'√©tat des mod√©rateurs
 * Centralise la gestion des profils, clients et messages
 */
import { defineStore } from 'pinia';
import axios from 'axios';
import webSocketManager from '../services/WebSocketManager';

export const useModeratorStore = defineStore('moderator', {
    state: () => ({
        // √âtat du mod√©rateur
        moderatorId: null,
        moderatorName: null,
        
        // Profils attribu√©s
        assignedProfiles: [],
        currentAssignedProfile: null,
        
        // Clients attribu√©s
        assignedClients: [],
        availableClients: [],
        
        // Conversation actuelle
        selectedClient: null,
        
        // Messages
        messages: {}, // Structure: { clientId: { messages: [], pagination: { page: 1, hasMore: true } } }
        
        // Notifications
        notifications: [],
        
        // √âtat de chargement
        loading: false,
        isLoadingMore: false,
        
        // √âtat de connexion WebSocket
        webSocketStatus: 'disconnected',
        
        // Erreurs
        errors: {
            profiles: null,
            clients: null,
            messages: null,
            websocket: null
        },

        initialized: false,
        heartbeatInterval: null,
        
        // √âtats de transition de profil
        profileTransition: {
            inProgress: false,
            countdown: 0,
            newProfile: null,
            countdownTimer: null,
            loadingData: false
        },
        // Nouvelles propri√©t√©s pour la gestion des profils partag√©s
        sharedProfiles: [],
        activeModeratorsByProfile: {},
        typingStatus: {},
        currentConversationActivity: null,
        canRequestDelay: true,
        delayRequested: false,
         // Nouvelles propri√©t√©s pour le syst√®me de file d'attente et verrouillage
        queueInfo: {
            inQueue: false,
            position: null,
            estimatedWaitTime: null,
            queuedAt: null
        },
        lockedProfiles: {}, // Structure: { profileId: { lockedAt, expiresAt, moderatorId } }
        lockedClients: {}, // Structure: { clientId: { lockedAt, expiresAt, profileId } }
        assignmentConflicts: [], // Stocke les conflits d'attribution en cours
    }),
    
    actions: {
        /**
         * Initialise le store avec les informations du mod√©rateur
         */
        async initialize() {
            try {
                console.log('üöÄ Initialisation du ModeratorStore...');
                
                // Chargement initial comme avant...
                await this.loadModeratorData();
                
                // S'assurer que le WebSocketManager est initialis√©
                this.webSocketStatus = webSocketManager.getConnectionStatus();
                if (this.webSocketStatus !== 'connected') {
                    console.log('‚è≥ Attente de l\'initialisation du WebSocketManager...');
                    await webSocketManager.initialize();
                    this.webSocketStatus = webSocketManager.getConnectionStatus();
                }
                
                // V√©rifier si le mod√©rateur est en file d'attente
                await this.checkQueueStatus();
                
                // Charger les profils attribu√©s
                await this.loadAssignedProfiles();
                
                // Si un profil principal est attribu√©, charger les clients
                if (this.currentAssignedProfile) {
                    await this.loadAssignedClients();
                    
                    // Configurer les √©couteurs WebSocket pour le profil principal
                    this.setupWebSocketListeners();
                } else if (this.queueInfo.inQueue) {
                    // Si le mod√©rateur est en file d'attente, afficher l'interface de file d'attente
                    console.log('üîç Mod√©rateur en file d\'attente, position: ' + this.queueInfo.position);
                }
                
                // Configurer les √©couteurs WebSocket pour le mod√©rateur
                this.setupModeratorWebSocketListeners();
                
                console.log('‚úÖ ModeratorStore initialis√© avec succ√®s');
                this.initialized = true;
                this.startHeartbeat();
                return true;
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'initialisation du ModeratorStore:', error);
                this.errors.profiles = 'Erreur lors du chargement des donn√©es';
                
                if (error.message && error.message.includes('WebSocket')) {
                    this.errors.websocket = 'Probl√®me de connexion WebSocket';
                }
                
                // R√©essayer l'initialisation apr√®s un d√©lai
                setTimeout(() => this.initialize(), 5000);
                return false;
            }
        },

        /**
         * V√©rifier le statut de file d'attente du mod√©rateur
         */
        async checkQueueStatus() {
            try {
                const response = await axios.get('/moderateur/queue/status');
                
                if (response.data.in_queue) {
                    this.queueInfo = {
                        inQueue: true,
                        position: response.data.position,
                        estimatedWaitTime: response.data.estimated_wait_time,
                        queuedAt: response.data.queued_at
                    };
                    console.log('üîç Mod√©rateur en file d\'attente, position: ' + this.queueInfo.position);
                } else {
                    this.queueInfo.inQueue = false;
                }
                
                return this.queueInfo;
            } catch (error) {
                console.error('‚ùå Erreur lors de la v√©rification du statut de file d\'attente:', error);
                return null;
            }
        },

        /**
         * G√©rer le changement de position dans la file d'attente
         */
        handleQueuePosition(event) {
            console.log('üì© √âv√©nement queue.position.changed re√ßu:', event);
            
            this.queueInfo = {
                inQueue: true,
                position: event.position,
                estimatedWaitTime: event.estimated_wait_time,
                queuedAt: event.timestamp
            };
            
            // Mettre √† jour l'interface pour refl√©ter la position dans la file d'attente
            this.showQueueStatus();
        },
        
        /**
         * G√©rer le statut de verrouillage d'un profil
         */
        handleProfileLockStatus(event) {
            console.log('üì© √âv√©nement profile.lock.status re√ßu:', event);
            
            if (event.status === 'locked') {
                // Ajouter ou mettre √† jour le verrouillage
                this.lockedProfiles[event.profile_id] = {
                    lockedAt: event.timestamp,
                    expiresAt: event.expires_at,
                    moderatorId: event.moderator_id
                };
            } else if (event.status === 'unlocked') {
                // Supprimer le verrouillage
                if (this.lockedProfiles[event.profile_id]) {
                    delete this.lockedProfiles[event.profile_id];
                }
            }
        },
        
        /**
         * Demander le d√©verrouillage d'un profil
         */
        async requestProfileUnlock(profileId) {
            try {
                const response = await axios.post('/moderateur/locks/request-unlock', {
                    profile_id: profileId
                });
                
                if (response.data.status === 'success') {
                    console.log('‚úÖ Demande de d√©verrouillage envoy√©e avec succ√®s');
                    
                    // Supprimer le verrouillage localement
                    if (this.lockedProfiles[profileId]) {
                        delete this.lockedProfiles[profileId];
                    }
                    
                    return true;
                }
                
                return false;
            } catch (error) {
                console.error('‚ùå Erreur lors de la demande de d√©verrouillage:', error);
                return false;
            }
        },
        
        /**
         * Afficher le statut de la file d'attente
         */
        showQueueStatus() {
            if (!this.queueInfo.inQueue) {
                return false;
            }
            
            const remainingTime = this.queueInfo.estimatedWaitTime;
            console.log(`üïí Position dans la file d'attente: ${this.queueInfo.position}, temps estim√©: ${remainingTime} minutes`);
            
            // Cette m√©thode peut √™tre utilis√©e pour mettre √† jour l'interface utilisateur
            // avec les informations de file d'attente
            
            return true;
        },
        
        /**
         * G√©rer la r√©solution des conflits
         */
        handleConflictResolution(event) {
            console.log('üì© √âv√©nement conflict.resolution re√ßu:', event);
            
            if (event.conflict_type === 'assignment') {
                // Stocker le conflit pour affichage
                this.assignmentConflicts.push({
                    id: Date.now(),
                    type: event.conflict_type,
                    message: event.message,
                    timestamp: event.timestamp,
                    details: event.details
                });
                
                // Si le conflit concerne le profil actuel, recharger les donn√©es
                if (event.details.profile_id === this.currentAssignedProfile?.id) {
                    this.loadAssignedProfiles();
                    this.loadAssignedClients();
                }
            }
        },
        
        /**
         * Charge les donn√©es du mod√©rateur connect√©
         */
        async loadModeratorData() {
            try {
                const response = await axios.get('/moderateur/user-data');
                this.moderatorId = response.data.id;
                this.moderatorName = response.data.name;
                console.log(`üë§ Mod√©rateur charg√©: ${this.moderatorName} (ID: ${this.moderatorId})`);
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement des donn√©es du mod√©rateur:', error);
                throw error;
            }
        },
        
        /**
         * Charge les profils attribu√©s au mod√©rateur
         */
        async loadAssignedProfiles() {
            this.loading = true;
            this.errors.profiles = null;
            
            try {
                console.log('üîç Chargement des profils attribu√©s...');
                const response = await axios.get('/moderateur/profile');
                
                if (response.data.profiles) {
                    this.assignedProfiles = response.data.profiles;
                    
                    // D√©finir le profil principal
                    if (response.data.primaryProfile) {
                        this.currentAssignedProfile = response.data.primaryProfile;
                        console.log(`‚úÖ Profil principal charg√©: ${this.currentAssignedProfile.name} (ID: ${this.currentAssignedProfile.id})`);
                    } else if (this.assignedProfiles.length > 0) {
                        // Si aucun profil principal n'est d√©fini mais des profils sont attribu√©s
                        this.currentAssignedProfile = this.assignedProfiles.find(p => p.isPrimary) || this.assignedProfiles[0];
                        console.log(`‚ö†Ô∏è Profil principal non d√©fini, utilisation du premier profil: ${this.currentAssignedProfile.name}`);
                    } else {
                        this.currentAssignedProfile = null;
                        console.warn('‚ö†Ô∏è Aucun profil attribu√©');
                    }
                } else {
                    this.assignedProfiles = [];
                    this.currentAssignedProfile = null;
                    console.warn('‚ö†Ô∏è Aucun profil retourn√© par l\'API');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement des profils:', error);
                this.errors.profiles = 'Erreur lors du chargement des profils';
                this.assignedProfiles = [];
                this.currentAssignedProfile = null;
            } finally {
                this.loading = false;
            }
        },
        
        /**
         * Charge les clients attribu√©s au mod√©rateur
         */
        async loadAssignedClients() {
            if (!this.currentAssignedProfile) {
                console.warn('‚ö†Ô∏è Impossible de charger les clients: aucun profil principal attribu√©');
                return;
            }
            
            this.loading = true;
            this.errors.clients = null;
            
            try {
                console.log('üîç Chargement des clients attribu√©s...');
                const response = await axios.get('/moderateur/clients');
                
                if (response.data.clients) {
                    this.assignedClients = response.data.clients;
                    console.log(`‚úÖ ${this.assignedClients.length} clients charg√©s`);
                    
                    // Si un client est s√©lectionn√©, mettre √† jour ses informations
                    if (this.selectedClient) {
                        const updatedClient = this.assignedClients.find(c => c.id === this.selectedClient.id);
                        if (updatedClient) {
                            this.selectedClient = updatedClient;
                        }
                    }
                } else {
                    this.assignedClients = [];
                    console.warn('‚ö†Ô∏è Aucun client retourn√© par l\'API');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement des clients:', error);
                this.errors.clients = 'Erreur lors du chargement des clients';
                this.assignedClients = [];
            } finally {
                this.loading = false;
            }
        },
        
        /**
         * Charge les clients disponibles
         */
        async loadAvailableClients() {
            if (!this.currentAssignedProfile) {
                console.warn('‚ö†Ô∏è Impossible de charger les clients disponibles: aucun profil principal attribu√©');
                return;
            }
            
            this.loading = true;
            
            try {
                console.log('üîç Chargement des clients disponibles...');
                const response = await axios.get('/moderateur/available-clients');
                
                if (response.data.availableClients) {
                    this.availableClients = response.data.availableClients;
                    console.log(`‚úÖ ${this.availableClients.length} clients disponibles charg√©s`);
                } else {
                    this.availableClients = [];
                    console.warn('‚ö†Ô∏è Aucun client disponible retourn√© par l\'API');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement des clients disponibles:', error);
                this.availableClients = [];
            } finally {
                this.loading = false;
            }
        },
        
        /**
         * S√©lectionne un client et charge ses messages
         */
        async selectClient(client) {
            this.selectedClient = client;
            
            // R√©initialiser la pagination
            if (!this.messages[client.id]) {
                this.messages[client.id] = {
                    messages: [],
                    pagination: { page: 1, hasMore: true }
                };
            } else {
                this.messages[client.id].pagination.page = 1;
                this.messages[client.id].pagination.hasMore = true;
            }
            
            // Charger les messages
            await this.loadMessages(client.id);
            
            // Marquer les notifications comme lues
            this.markClientNotificationsAsRead(client.id);
            
            // Mettre √† jour le compteur de messages non lus dans la liste des clients
            const clientIndex = this.assignedClients.findIndex(c => c.id === client.id);
            if (clientIndex !== -1) {
                this.assignedClients[clientIndex].unreadCount = 0;
            }
        },
        
        /**
         * Charge les messages d'un client
         */
        async loadMessages(clientId, page = 1, append = false) {
            if (!this.currentAssignedProfile) {
                console.warn('‚ö†Ô∏è Impossible de charger les messages: aucun profil principal attribu√©');
                return;
            }
            
            if (append) {
                this.isLoadingMore = true;
            } else {
                this.loading = true;
            }
            
            this.errors.messages = null;
            
            try {
                console.log(`üîç Chargement des messages pour le client ${clientId}, page ${page}...`);
                
                const response = await axios.get('/moderateur/messages', {
                    params: {
                        client_id: clientId,
                        profile_id: this.currentAssignedProfile.id,
                        page: page,
                        per_page: 20 // Nombre de messages par page
                    }
                });
                
                // Initialiser l'entr√©e si n√©cessaire
                if (!this.messages[clientId]) {
                    this.messages[clientId] = {
                        messages: [],
                        pagination: { page: 1, hasMore: true }
                    };
                }
                
                if (response.data.messages) {
                    const loadedMessages = response.data.messages;
                    console.log(`‚úÖ ${loadedMessages.length} messages charg√©s`);
                    
                    // Mettre √† jour les messages
                    if (append) {
                        // Ajouter au d√©but pour les messages plus anciens
                        this.messages[clientId].messages = [...loadedMessages, ...this.messages[clientId].messages];
                    } else {
                        this.messages[clientId].messages = loadedMessages;
                    }
                    
                    // Mettre √† jour la pagination
                    this.messages[clientId].pagination = {
                        page: page,
                        hasMore: loadedMessages.length >= 20 // S'il y a au moins 20 messages, il y en a probablement plus
                    };
                } else {
                    if (!append) {
                        this.messages[clientId].messages = [];
                    }
                    this.messages[clientId].pagination.hasMore = false;
                    console.warn('‚ö†Ô∏è Aucun message retourn√© par l\'API');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement des messages:', error);
                this.errors.messages = 'Erreur lors du chargement des messages';
                
                if (!append) {
                    this.messages[clientId].messages = [];
                }
            } finally {
                if (append) {
                    this.isLoadingMore = false;
                } else {
                    this.loading = false;
                }
            }
        },
        
        /**
         * Charge plus de messages (messages plus anciens)
         */
        async loadMoreMessages(clientId) {
            if (!this.messages[clientId] || !this.messages[clientId].pagination.hasMore || this.isLoadingMore) {
                return;
            }
            
            const nextPage = this.messages[clientId].pagination.page + 1;
            await this.loadMessages(clientId, nextPage, true);
        },
        
        /**
         * Envoie un message √† un client
         */
        async sendMessage({ clientId, profileId, content, file }) {
            try {
                // G√©n√©ration d'un ID temporaire pour le message
                const tempId = Date.now().toString();
                
                // Ajouter un message temporaire √† l'interface utilisateur imm√©diatement
                const tempMessage = {
                id: tempId,
                content: content || '',
                sender_id: profileId,
                sender_type: 'profile',
                isFromClient: false,
                time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                isSending: true
                };

                // Initialiser l'entr√©e si n√©cessaire
                if (!this.messages[clientId]) {
                this.messages[clientId] = {
                    messages: [],
                    pagination: { page: 1, hasMore: false }
                };
                }
                
                // Ajouter √† notre liste de messages (notez l'acc√®s √† .messages)
                this.messages[clientId].messages.push(tempMessage);

                // Construire les donn√©es pour la requ√™te
                const formData = new FormData();
                formData.append('client_id', clientId);
                formData.append('profile_id', profileId);
                if (content) formData.append('content', content);
                if (file) formData.append('attachment', file);

                // Envoyer le message au serveur
                const response = await axios.post('/moderateur/send-message', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
                });

                // Mettre √† jour le message temporaire avec les donn√©es r√©elles
                if (response.data.success) {
                // R√©cup√©rer le message de la r√©ponse en v√©rifiant sa structure
                const actualMessage = response.data.message || response.data.messageData;
                
                if (actualMessage) {
                    // Remplacer le message temporaire par le message r√©el
                    const tempIndex = this.messages[clientId].messages.findIndex(m => m.id === tempId);
                    if (tempIndex !== -1) {
                    // Cr√©er un nouvel objet message avec les bons champs
                    const formattedMessage = {
                        id: actualMessage.id || tempId,
                        content: actualMessage.content || content || '',
                        isFromClient: false,
                        time: actualMessage.created_at 
                        ? new Date(actualMessage.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        : tempMessage.time
                    };
                    
                    // Ajouter l'attachment si pr√©sent
                    if (actualMessage.attachment) {
                        formattedMessage.attachment = actualMessage.attachment;
                    }
                    
                    this.messages[clientId].messages[tempIndex] = formattedMessage;
                    }
                } else {
                    console.warn("Message envoy√© mais structure de r√©ponse API inattendue");
                    // Marquer le message comme envoy√© en supprimant l'indicateur de chargement
                    const tempIndex = this.messages[clientId].messages.findIndex(m => m.id === tempId);
                    if (tempIndex !== -1) {
                    this.messages[clientId].messages[tempIndex].isSending = false;
                    }
                }
                }

                return response.data;
            } catch (error) {
                console.error("‚ùå Erreur lors de l'envoi du message:", error);
                
                // En cas d'erreur, marquer le message comme √©chou√©
                if (this.messages[clientId] && this.messages[clientId].messages) {
                const tempIndex = this.messages[clientId].messages.findIndex(m => m.id === tempId);
                if (tempIndex !== -1) {
                    this.messages[clientId].messages[tempIndex].failed = true;
                    this.messages[clientId].messages[tempIndex].isSending = false;
                }
                }
                
                throw error;
            }
        },
        
        /**
         * Envoie une photo de profil √† un client
         */
        async sendProfilePhoto({ profileId, clientId, photoId, photoUrl }) {
            try {
                const response = await axios.post('/moderateur/send-profile-photo', {
                    profile_id: profileId,
                    client_id: clientId,
                    photo_id: photoId
                });
                
                if (response.data.success) {
                    // Cr√©er un message local pour la photo
                    const now = new Date();
                    const photoMessage = {
                        id: response.data.messageId || `photo-${Date.now()}`,
                        content: '',
                        isFromClient: false,
                        time: now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                        date: now.toISOString().split('T')[0],
                        created_at: now.toISOString(),
                        attachment: {
                            url: photoUrl,
                            file_name: 'profile-photo.jpg',
                            mime_type: 'image/jpeg'
                        }
                    };
                    
                    // Initialiser l'entr√©e si n√©cessaire
                    if (!this.messages[clientId]) {
                        this.messages[clientId] = {
                            messages: [],
                            pagination: { page: 1, hasMore: false }
                        };
                    }
                    
                    // Ajouter le message
                    this.messages[clientId].messages.push(photoMessage);
                    
                    console.log('‚úÖ Photo de profil envoy√©e avec succ√®s');
                    return photoMessage;
                } else {
                    throw new Error('Erreur lors de l\'envoi de la photo de profil');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'envoi de la photo de profil:', error);
                return null;
            }
        },
        
        /**
         * D√©marre une conversation avec un client disponible
         */
        async startConversation(clientId) {
            if (!this.currentAssignedProfile) {
                console.error('‚ùå Impossible de d√©marrer une conversation: aucun profil principal attribu√©');
                return false;
            }
            
            this.loading = true;
            
            try {
                console.log(`üîÑ D√©marrage d'une conversation avec le client ${clientId}...`);
                
                const response = await axios.post('/moderateur/start-conversation', {
                    client_id: clientId,
                    profile_id: this.currentAssignedProfile.id
                });
                
                if (response.data.success) {
                    // Stocker les messages
                    this.messages[clientId] = {
                        messages: response.data.messages || [],
                        pagination: { page: 1, hasMore: false }
                    };
                    
                    // Ajouter le client √† la liste des clients attribu√©s
                    const newClient = {
                        ...response.data.client,
                        profileId: this.currentAssignedProfile.id,
                        profileName: this.currentAssignedProfile.name,
                        profilePhoto: this.currentAssignedProfile.main_photo_path,
                        unreadCount: 0
                    };
                    
                    this.assignedClients.unshift(newClient);
                    
                    // S√©lectionner ce client
                    this.selectedClient = newClient;
                    
                    console.log('‚úÖ Conversation d√©marr√©e avec succ√®s');
                    return true;
                } else {
                    throw new Error('Erreur lors du d√©marrage de la conversation');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors du d√©marrage de la conversation:', error);
                return false;
            } finally {
                this.loading = false;
            }
        },
        
        /**
         * Ajoute une notification
         */
        addNotification(message, clientId, clientName) {
            const notification = {
                id: Date.now(),
                message,
                clientId,
                clientName,
                timestamp: new Date(),
                read: false
            };
            
            this.notifications.unshift(notification);
            
            // Limiter √† 50 notifications maximum
            if (this.notifications.length > 50) {
                this.notifications = this.notifications.slice(0, 50);
            }
            
            // Mettre √† jour le compteur de messages non lus dans la liste des clients
            const clientIndex = this.assignedClients.findIndex(c => c.id === clientId);
            if (clientIndex !== -1) {
                this.assignedClients[clientIndex].unreadCount = (this.assignedClients[clientIndex].unreadCount || 0) + 1;
                
                // Mettre √† jour la date pour le tri
                this.assignedClients[clientIndex].lastMessageAt = new Date().toISOString();
            }
        },
        
        /**
         * Marque une notification comme lue
         */
        markNotificationAsRead(notificationId) {
            const index = this.notifications.findIndex(n => n.id === notificationId);
            if (index !== -1) {
                this.notifications[index].read = true;
            }
        },
        
        /**
         * Marque toutes les notifications d'un client comme lues
         */
        markClientNotificationsAsRead(clientId) {
            this.notifications.forEach(notification => {
                if (notification.clientId === clientId) {
                    notification.read = true;
                }
            });
        },
        
        /**
         * Configure les √©couteurs WebSocket pour le profil principal
         */
        setupWebSocketListeners() {
            if (!this.currentAssignedProfile) {
                console.warn('‚ö†Ô∏è Impossible de configurer les √©couteurs WebSocket: aucun profil principal attribu√©');
                return;
            }
            
            try {
                const profileId = this.currentAssignedProfile.id;
                console.log(`üîÑ Configuration des √©couteurs WebSocket pour le profil ${profileId}...`);
                
                // S'abonner au canal du profil
                webSocketManager.subscribeToPrivateChannel(`profile.${profileId}`, {
                    '.message.sent': (data) => {
                        console.log('üì© Nouveau message re√ßu sur le canal profile:', data);
                        
                        // Traiter uniquement les messages des clients
                        if (data.is_from_client) {
                            const clientId = data.client_id;
                            
                            // V√©rifier si le message n'existe pas d√©j√†
                            if (this.messages[clientId]?.messages.some(msg => msg.id === data.id)) {
                                console.log('‚ö†Ô∏è Message d√©j√† existant, ignor√©');
                                return;
                            }
                            
                            // Ajouter une notification
                            const clientName = this.assignedClients.find(c => c.id === clientId)?.name || 'Client';
                            this.addNotification(data.content, clientId, clientName);
                            
                            // Formater le message
                            const message = {
                                id: data.id,
                                content: data.content,
                                isFromClient: true,
                                time: new Date(data.created_at).toLocaleTimeString([], {
                                    hour: '2-digit',
                                    minute: '2-digit'
                                }),
                                date: new Date(data.created_at).toISOString().split('T')[0],
                                created_at: data.created_at
                            };
                            
                            // Ajouter l'attachement si pr√©sent
                            if (data.attachment) {
                                message.attachment = {
                                    url: data.attachment.url,
                                    file_name: data.attachment.file_name,
                                    mime_type: data.attachment.mime_type
                                };
                            }
                            
                            // Initialiser le tableau de messages si n√©cessaire
                            if (!this.messages[clientId]) {
                                this.messages[clientId] = {
                                    messages: [],
                                    pagination: { page: 1, hasMore: false }
                                };
                            }
                            
                            // Ajouter le nouveau message
                            this.messages[clientId].messages.push(message);
                            
                            // V√©rifier si le client existe dans la liste des clients attribu√©s
                            const clientExists = this.assignedClients.some(c => c.id === clientId);
                            
                            if (!clientExists) {
                                // Recharger la liste des clients en arri√®re-plan
                                this.loadAssignedClients();
                            }
                        }
                    }
                });
                
                // Surveiller l'√©tat de la connexion WebSocket
                window.addEventListener('websocket:disconnected', this.handleWebSocketDisconnected);
                window.addEventListener('websocket:connected', this.handleWebSocketConnected);
                
                // NOUVEAU: Ajouter l'√©coute des √©v√©nements de profil partag√©
                this.listenToSharedProfileEvents(profileId);
                
                // NOUVEAU: V√©rifier si ce profil est partag√©
                if (!this.sharedProfiles.includes(profileId)) {
                    axios.get(`/moderateur/profile/${profileId}/is-shared`)
                        .then(response => {
                            if (response.data.isShared) {
                                this.sharedProfiles.push(profileId);
                            }
                        })
                        .catch(error => console.error('Erreur lors de la v√©rification du partage de profil:', error));
                }
                
            } catch (error) {
                console.error('‚ùå Erreur lors de la configuration des √©couteurs WebSocket:', error);
                this.errors.websocket = 'Erreur de configuration WebSocket';
            }
        },
        
        /**
         * G√®re la d√©connexion WebSocket
         */
        handleWebSocketDisconnected() {
            console.warn('üî¥ WebSocket d√©connect√© dans le ModeratorStore');
            this.webSocketStatus = 'disconnected';
            this.errors.websocket = 'Connexion WebSocket perdue. Tentative de reconnexion...';
        },
        
        /**
         * G√®re la reconnexion WebSocket
         */
        handleWebSocketConnected() {
            console.log('üü¢ WebSocket reconnect√© dans le ModeratorStore');
            this.webSocketStatus = 'connected';
            this.errors.websocket = null;
            
            // Reconfigurer les √©couteurs apr√®s reconnexion
            if (this.currentAssignedProfile) {
                this.setupWebSocketListeners();
                this.setupModeratorWebSocketListeners();
            }
        },

        // M√©thode pour g√©rer les conflits d'attribution
        handleAssignmentConflict(event) {
            console.log('üì© √âv√©nement assignment.conflict re√ßu:', event);
            
            if (event.resolution === 'reassign') {
                // Afficher une notification √† l'utilisateur
                this.addNotification(
                    `Un conflit d'attribution a √©t√© d√©tect√©. Votre profil ${event.profile_name} a √©t√© r√©attribu√©.`,
                    null,
                    'Syst√®me'
                );
                
                // Recharger les profils attribu√©s
                this.loadAssignedProfiles();
            }
        },
        
        /**
         * Configure les √©couteurs WebSocket pour le mod√©rateur
         */
        setupModeratorWebSocketListeners() {
            if (!this.moderatorId) {
                console.warn('‚ö†Ô∏è Impossible de configurer les √©couteurs WebSocket: ID du mod√©rateur non disponible');
                return;
            }
            
            console.log(`üîÑ Configuration des √©couteurs WebSocket pour le mod√©rateur ${this.moderatorId}...`);
            
            // S'abonner au canal du mod√©rateur
            webSocketManager.subscribeToPrivateChannel(`moderator.${this.moderatorId}`, {
                '.profile.assigned': async (data) => {
                    console.log('üì© √âv√©nement profile.assigned re√ßu:', data);
                    console.log('üìä √âtat actuel du store avant traitement:', {
                        currentProfile: this.currentAssignedProfile ? this.currentAssignedProfile.id : null,
                        assignedProfiles: this.assignedProfiles.map(p => p.id),
                        isReassignment: data.reason === 'inactivity' || data.old_moderator_id,
                        isForced: data.forced === true,
                        reason: data.reason,
                        oldModeratorId: data.old_moderator_id
                    });
                    
                    // Recharger les donn√©es apr√®s l'attribution d'un profil
                    await this.loadAssignedProfiles();
                    
                    // V√©rifier si c'est une r√©attribution forc√©e (inactivit√©)
                    
                    // Am√©lioration: V√©rification plus robuste des conditions de r√©attribution forc√©e
                    const isReassignment = data.reason === 'inactivity' || data.old_moderator_id;
                    const isForced = data.forced === true;
                    
                    // Debug suppl√©mentaire pour la r√©attribution
                    console.log('üîç Analyse de l\'√©v√©nement profile.assigned:', {
                        isReassignment,
                        isForced,
                        reason: data.reason,
                        oldModeratorId: data.old_moderator_id,
                        profileId: data.profileId || (data.profile ? data.profile.id : null),
                        currentProfileId: this.currentAssignedProfile ? this.currentAssignedProfile.id : null
                    });
                    
                    // Forcer la mise √† jour du profil actuel si:
                    // 1. Le profil principal a chang√©
                    // 2. C'est une r√©attribution forc√©e (inactivit√©)
                    // 3. L'√©v√©nement indique explicitement que c'est forc√©

                    
                    if (data.profile && data.is_primary && 
                            (!this.currentAssignedProfile || data.profile.id !== this.currentAssignedProfile.id) ||
                        isReassignment || 
                        isForced) {
                        console.log('üîÑ Changement de profil d√©tect√©, pr√©paration de la transition...', {
                            newProfileId: data.profile ? data.profile.id : (data.profileId || 'non sp√©cifi√©'),
                            reason: data.reason || 'non sp√©cifi√©',
                            isForced: isForced,
                            isReassignment: isReassignment
                        });

                        
                       
                        
                        // D√©marrer le compte √† rebours pour le changement de profil
                        this.startProfileTransition(data.profile);
                        
                        // Attendre la fin du compte √† rebours
                        await new Promise(resolve => {
                            setTimeout(resolve, 3000); // 3 secondes de compte √† rebours
                        });
                        
                        // Activer l'√©tat de chargement global
                        this.profileTransition.loadingData = true;
                        
                        try {
                            console.log('üîÑ Chargement du nouveau profil en cours...');
                            
                            // R√©initialiser le client s√©lectionn√© et vider le chat avant de changer de profil
                            this.selectedClient = null;
                            
                            // Mettre √† jour le profil principal
                            this.currentAssignedProfile = data.profile;
                            
                            // Recharger les clients
                            await this.loadAssignedClients();
                            
                            // Configurer les √©couteurs WebSocket pour le nouveau profil
                            this.setupWebSocketListeners();
                            
                            // Si un client est associ√© √† ce changement de profil
                            if (data.client_id) {
                                // Charger les messages du client
                                await this.loadMessages(data.client_id);
                                
                                // Trouver et s√©lectionner le client
                                const clientInfo = this.assignedClients.find(c => c.id === data.client_id);
                                if (clientInfo) {
                                    this.selectedClient = clientInfo;
                                }
                            } else if (this.assignedClients.length > 0) {
                                // Si aucun client sp√©cifique n'est associ√© mais qu'il y a des clients attribu√©s,
                                // s√©lectionner le premier client de la liste pour √©viter un chat vide
                                const firstClient = this.assignedClients[0];
                                this.selectedClient = firstClient;
                                await this.loadMessages(firstClient.id);
                            }
                            
                            console.log('‚úÖ Transition de profil termin√©e avec succ√®s');
                        } catch (error) {
                            console.error('‚ùå Erreur lors de la transition de profil:', error);
                        } finally {
                            // D√©sactiver l'√©tat de chargement
                            this.profileTransition.loadingData = false;
                            this.endProfileTransition();
                        }
                    } else {
                        console.log('‚ÑπÔ∏è Mise √† jour des donn√©es sans changement de profil principal');
                    }
                },
                
                '.client.assigned': async (data) => {
                    console.log('üì© √âv√©nement client.assigned re√ßu:', data);
                    
                    // Recharger les donn√©es apr√®s l'attribution d'un client
                    await this.loadAssignedClients();
                    
                    // Si c'est un nouveau client et qu'il n'y a pas de client s√©lectionn√©,
                    // on le s√©lectionne automatiquement
                    if (!this.selectedClient && data.client) {
                        const clientInfo = this.assignedClients.find(c => c.id === data.client.id);
                        if (clientInfo) {
                            await this.selectClient(clientInfo);
                        }
                    }
                },
                // Nouvel √©couteur pour les changements de position dans la file d'attente
                '.queue.position.changed': (data) => {
                    this.handleQueuePosition(data);
                },
                
                // Nouvel √©couteur pour les changements de statut de verrouillage des profils
                '.profile.lock.status': (data) => {
                    this.handleProfileLockStatus(data);
                },
                
                // Nouvel √©couteur pour la r√©solution des conflits
                '.conflict.resolution': (data) => {
                    this.handleConflictResolution(data);
                },
                'assignment.conflict': (event) => {
                    this.handleAssignmentConflict(event);
                },
            });
        },
        
        /**
         * D√©marre la transition vers un nouveau profil avec un compte √† rebours
         */
        startProfileTransition(newProfile) {
            // Annuler tout compte √† rebours en cours
            if (this.profileTransition.countdownTimer) {
                clearInterval(this.profileTransition.countdownTimer);
            }
            
            // Initialiser l'√©tat de transition
            this.profileTransition.inProgress = true;
            this.profileTransition.countdown = 3; // 3 secondes de compte √† rebours
            this.profileTransition.newProfile = newProfile;
            
            // D√©marrer le compte √† rebours
            this.profileTransition.countdownTimer = setInterval(() => {
                this.profileTransition.countdown -= 1;
                
                // Si le compte √† rebours est termin√©, arr√™ter le timer
                if (this.profileTransition.countdown <= 0) {
                    clearInterval(this.profileTransition.countdownTimer);
                    this.profileTransition.countdownTimer = null;
                }
            }, 1000);
        },
        
        /**
         * Termine la transition de profil
         */
        endProfileTransition() {
            // R√©initialiser l'√©tat de transition
            this.profileTransition.inProgress = false;
            this.profileTransition.countdown = 0;
            this.profileTransition.newProfile = null;
            this.profileTransition.loadingData = false;
            
            // Annuler le compte √† rebours si n√©cessaire
            if (this.profileTransition.countdownTimer) {
                clearInterval(this.profileTransition.countdownTimer);
                this.profileTransition.countdownTimer = null;
            }
        },
        
        /**
         * Retourne les messages pour un client sp√©cifique
         */
        getMessagesForClient(clientId) {
            return this.messages[clientId]?.messages || [];
        },
        
        /**
         * V√©rifie s'il y a plus de messages √† charger pour un client
         */
        hasMoreMessages(clientId) {
            return this.messages[clientId]?.pagination.hasMore || false;
        },
        
        /**
         * Retourne un client par son ID
         */
        getClientById(clientId) {
            return this.assignedClients.find(c => c.id === clientId);
        },
        
        /**
         * Retourne les clients attribu√©s tri√©s par date du dernier message
         */
        getSortedAssignedClients() {
            return [...this.assignedClients].sort((a, b) => {
                // Trier par date de dernier message (du plus r√©cent au plus ancien)
                const dateA = a.lastMessageAt ? new Date(a.lastMessageAt) : new Date(0);
                const dateB = b.lastMessageAt ? new Date(b.lastMessageAt) : new Date(0);
                return dateB - dateA;
            });
        },

        /**
         * Configure les √©couteurs WebSocket pour un profil sp√©cifique
         * @param {number} profileId - ID du profil
         */
        setupProfileListeners(profileId) {
            if (!profileId) {
                console.warn('‚ö†Ô∏è Impossible de configurer les √©couteurs: ID de profil non fourni');
                return;
            }
            
            try {
                console.log(`üîä Configuration des √©couteurs pour le profil ${profileId}`);
                
                // S'abonner au canal du profil
                const channelName = `profile.${profileId}`;
                webSocketManager.subscribeToPrivateChannel(channelName, {
                    // √âv√©nement de nouveau message
                    'message.received': (data) => {
                        console.log(`üì® Nouveau message re√ßu sur le canal ${channelName}:`, data);
                        this.handleNewMessage(data);
                    },
                    
                    // √âv√©nement de client en ligne
                    'client.online': (data) => {
                        console.log(`üü¢ Client en ligne sur le canal ${channelName}:`, data);
                        this.updateClientStatus(data.clientId, true);
                    },
                    
                    // √âv√©nement de client hors ligne
                    'client.offline': (data) => {
                        console.log(`üî¥ Client hors ligne sur le canal ${channelName}:`, data);
                        this.updateClientStatus(data.clientId, false);
                    }
                });
            } catch (error) {
                console.error(`‚ùå Erreur lors de la configuration des √©couteurs pour le profil ${profileId}:`, error);
            }
        },
        
        /**
         * Nettoie les ressources du store
         */
        cleanup() {
            // Se d√©sabonner des canaux WebSocket
            if (this.currentAssignedProfile) {
                webSocketManager.unsubscribeFromChannel(`profile.${this.currentAssignedProfile.id}`);
            }
            
            if (this.moderatorId) {
                webSocketManager.unsubscribeFromChannel(`moderator.${this.moderatorId}`);
            }
            
            // Supprimer les √©couteurs d'√©v√©nements
            window.removeEventListener('websocket:disconnected', this.handleWebSocketDisconnected);
            window.removeEventListener('websocket:connected', this.handleWebSocketConnected);
            
            console.log('üßπ ModeratorStore nettoy√©');
        },

        /**
         * Envoie un signal heartbeat pour indiquer que le mod√©rateur est actif
         * Cette fonction est appel√©e p√©riodiquement pour maintenir le statut en ligne
         */
        async sendHeartbeat() {
            try {
                const response = await axios.post('/moderateur/heartbeat');
                
                if (response.data.success) {
                    // Mettre √† jour l'√©tat local si n√©cessaire
                    console.log('‚úÖ Heartbeat envoy√© avec succ√®s');
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'envoi du heartbeat:', error);
                return false;
            }
        },

        startHeartbeat() {
            if (!this.initialized) return; // Guard
            if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = setInterval(() => {
                if (this.initialized) this.sendHeartbeat();
            }, 30000);
        },

        /**
         * Enregistre l'activit√© de frappe
         */
        async recordTypingActivity(profileId, clientId) {
            // V√©rifier si une requ√™te est d√©j√† en cours pour √©viter les requ√™tes multiples
            const typingKey = `${profileId}-${clientId}`;
            
            // Si le statut existe d√©j√† et qu'il est r√©cent (moins de 2 secondes), ne rien faire
            if (this.typingStatus[typingKey] && 
                this.typingStatus[typingKey].timestamp && 
                (new Date().getTime() - new Date(this.typingStatus[typingKey].timestamp).getTime() < 2000)) {
                return;
            }
            
            try {
                // Mettre √† jour l'√©tat local avant d'envoyer la requ√™te
                this.typingStatus[typingKey] = {
                    isTyping: true,
                    timestamp: new Date(),
                };
                
                // Envoyer la requ√™te au serveur
                await axios.post('/moderateur/typing', {
                    profile_id: profileId,
                    client_id: clientId,
                });
                
                // Effacer le statut apr√®s 5 secondes
                setTimeout(() => {
                    if (this.typingStatus[typingKey]) {
                        this.typingStatus[typingKey].isTyping = false;
                    }
                }, 5000);
            } catch (error) {
                console.error('Erreur lors de l\'enregistrement de l\'activit√©:', error);
            }
        },

        /**
         * Met √† jour l'activit√© de derni√®re r√©ponse pour un profil et un client
         */
        updateLastMessageActivity(profileId, clientId) {
            try {
                // Mettre √† jour l'√©tat local pour indiquer que le mod√©rateur a r√©pondu
                const key = `${profileId}-${clientId}`;
                this.currentConversationActivity = {
                    profileId,
                    clientId,
                    lastResponse: new Date(),
                };
                
                // Vous pouvez √©galement envoyer cette information au serveur si n√©cessaire
                axios.post('/moderateur/update-activity', {
                    profile_id: profileId,
                    client_id: clientId,
                    activity_type: 'message_sent'
                }).catch(error => {
                    console.warn('Erreur lors de la mise √† jour de l\'activit√©:', error);
                });
                
                return true;
            } catch (error) {
                console.error('Erreur lors de la mise √† jour de l\'activit√© de message:', error);
                return false;
            }
        },

        /**
         * Demander un d√©lai avant changement de profil
         */
        async requestProfileChangeDelay(profileId, minutes = 5) {
            if (!this.canRequestDelay) return false;
            
            try {
                const response = await axios.post('/moderateur/request-delay', {
                    profile_id: profileId,
                    minutes: minutes,
                });
                
                if (response.data.status === 'success') {
                    this.delayRequested = true;
                    this.canRequestDelay = false;
                    
                    // R√©initialiser apr√®s un certain temps
                    setTimeout(() => {
                        this.canRequestDelay = true;
                    }, 15 * 60 * 1000); // 15 minutes
                    
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Erreur lors de la demande de d√©lai:', error);
                return false;
            }
        },

         /**
         * √âcouter les √©v√©nements de profil partag√©
         */
        listenToSharedProfileEvents(profileId) {
            if (!window.Echo) return;
            
            window.Echo.private(`profile.${profileId}`)
                .listen('ModeratorActivityEvent', (event) => {
                    // Mettre √† jour l'√©tat des activit√©s des autres mod√©rateurs
                    if (event.moderatorId !== this.moderatorId) {
                        this.activeModeratorsByProfile[profileId] = this.activeModeratorsByProfile[profileId] || [];
                        
                        // Ajouter ou mettre √† jour l'activit√© du mod√©rateur
                        const existingIndex = this.activeModeratorsByProfile[profileId].findIndex(
                            m => m.moderatorId === event.moderatorId
                        );
                        
                        const activityData = {
                            moderatorId: event.moderatorId,
                            clientId: event.clientId,
                            activityType: event.activityType,
                            timestamp: event.timestamp,
                        };
                        
                        if (existingIndex >= 0) {
                            this.activeModeratorsByProfile[profileId][existingIndex] = activityData;
                        } else {
                            this.activeModeratorsByProfile[profileId].push(activityData);
                        }
                        
                        // Nettoyer les activit√©s anciennes
                        this.cleanupOldActivities();
                    }
                });
        },

        /**
         * Nettoyer les activit√©s anciennes (plus de 5 minutes)
         */
        cleanupOldActivities() {
            const now = new Date();
            
            Object.keys(this.activeModeratorsByProfile).forEach(profileId => {
                this.activeModeratorsByProfile[profileId] = this.activeModeratorsByProfile[profileId].filter(activity => {
                    const activityTime = new Date(activity.timestamp);
                    return now.getTime() - activityTime.getTime() < 5 * 60 * 1000;
                });
            });
        },

        /**
         * Force le rechargement des donn√©es du profil courant
         * Utile quand les donn√©es ne sont pas automatiquement mises √† jour
         */
        async forceProfileRefresh() {
            console.log('üîÑ For√ßage du rechargement des donn√©es du profil...');
            
            try {
                // Recharger les profils assign√©s
                await this.loadAssignedProfiles();
                
                // Si un profil est actuellement assign√©, recharger ses clients
                if (this.currentAssignedProfile) {
                    await this.loadAssignedClients();
                    
                    // Si un client est s√©lectionn√©, recharger ses messages
                    if (this.selectedClient) {
                        await this.loadMessages(this.selectedClient.id);
                    }
                }
                
                console.log('‚úÖ Rechargement forc√© des donn√©es termin√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors du rechargement forc√© des donn√©es:', error);
            }
        },
    }
});